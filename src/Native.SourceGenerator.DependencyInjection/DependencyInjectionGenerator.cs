namespace Native.SourceGenerator.DependencyInjection;

using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Native.SourceGenerator.DependencyInjection.Emitters;
using Native.SourceGenerator.DependencyInjection.Models;
using Native.SourceGenerator.DependencyInjection.Parsing;

/// <summary>
/// Incremental source generator for AOT-compatible dependency injection.
/// Generates constructors and service registration code without reflection.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class DependencyInjectionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register attribute sources
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource("RegisterAttribute.g.cs", GetRegisterAttributeSource());
            ctx.AddSource("InjectAttribute.g.cs", GetInjectAttributeSource());
        });

        // Find all classes with [Register] attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, ct) => AttributeParser.HasRegisterAttribute(node, ct),
                transform: static (ctx, ct) => AttributeParser.ParseServiceRegistration(ctx, ct))
            .Where(static info => info is not null)
            .Select(static (info, _) => info!.Value);

        // Generate constructors for each class
        context.RegisterSourceOutput(classDeclarations, static (ctx, info) =>
        {
            var constructorSource = ConstructorEmitter.EmitConstructor(info);
            if (!string.IsNullOrEmpty(constructorSource))
            {
                ctx.AddSource($"{info.ClassName}.Constructor.g.cs", constructorSource);
            }
        });

        // Collect all registrations and generate service registration extension
        var allRegistrations = classDeclarations.Collect();
        context.RegisterSourceOutput(allRegistrations, static (ctx, registrations) =>
        {
            var registrationSource = ServiceRegistrationEmitter.EmitServiceRegistrations(registrations);
            if (!string.IsNullOrEmpty(registrationSource))
            {
                ctx.AddSource("NativeGeneratedServices.g.cs", registrationSource);
            }
        });
    }

    private static string GetRegisterAttributeSource() => """
        // <auto-generated />
        #nullable enable

        namespace Native.SourceGenerator.DependencyInjection
        {
            /// <summary>
            /// Marks a class for automatic service registration and constructor generation.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
            internal sealed class RegisterAttribute : global::System.Attribute
            {
                /// <summary>
                /// The service type to register. If null, the class itself is registered.
                /// </summary>
                public global::System.Type? ServiceType { get; }

                /// <summary>
                /// The service lifetime.
                /// </summary>
                public ServiceLifetime Lifetime { get; }

                /// <summary>
                /// Optional group name for organizing service registrations.
                /// </summary>
                public string? Group { get; set; }

                /// <summary>
                /// Registers the class as itself with Singleton lifetime.
                /// </summary>
                public RegisterAttribute()
                {
                    ServiceType = null;
                    Lifetime = ServiceLifetime.Singleton;
                }

                /// <summary>
                /// Registers the class as the specified service type with Singleton lifetime.
                /// </summary>
                public RegisterAttribute(global::System.Type serviceType)
                {
                    ServiceType = serviceType;
                    Lifetime = ServiceLifetime.Singleton;
                }

                /// <summary>
                /// Registers the class as the specified service type with the specified lifetime.
                /// </summary>
                public RegisterAttribute(global::System.Type serviceType, ServiceLifetime lifetime)
                {
                    ServiceType = serviceType;
                    Lifetime = lifetime;
                }
            }

            /// <summary>
            /// Service lifetime options.
            /// </summary>
            internal enum ServiceLifetime
            {
                /// <summary>
                /// A single instance is created and shared.
                /// </summary>
                Singleton = 0,

                /// <summary>
                /// A new instance is created for each scope.
                /// </summary>
                Scoped = 1,

                /// <summary>
                /// A new instance is created each time it is requested.
                /// </summary>
                Transient = 2
            }
        }
        """;

    private static string GetInjectAttributeSource() => """
        // <auto-generated />
        #nullable enable

        namespace Native.SourceGenerator.DependencyInjection
        {
            /// <summary>
            /// Marks a field for dependency injection via constructor generation.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
            internal sealed class InjectAttribute : global::System.Attribute
            {
            }
        }
        """;
}
