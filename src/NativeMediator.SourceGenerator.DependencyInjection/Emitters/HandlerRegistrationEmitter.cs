namespace NativeMediator.SourceGenerator.DependencyInjection.Emitters;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using NativeMediator.SourceGenerator.DependencyInjection.Models;

internal static class HandlerRegistrationEmitter
{
    public static string EmitHandlerRegistrations(IEnumerable<HandlerRegistrationInfo> registrations)
    {
        var registrationsList = registrations.ToList();
        if (registrationsList.Count == 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        sb.AppendLine("namespace Microsoft.Extensions.DependencyInjection");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Extension methods for registering NativeMediator handlers.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static class NativeMediatorServicesExtensions");
        sb.AppendLine("    {");

        // Main method that adds all handlers
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Adds all generated NativeMediator handlers to the service collection.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddNativeMediatorHandlers(");
        sb.AppendLine("            this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
        sb.AppendLine("        {");

        foreach (HandlerRegistrationInfo registration in registrationsList)
        {
            EmitHandlerRegistration(sb, registration);
        }

        sb.AppendLine("            return services;");
        sb.AppendLine("        }");

        // Group by Group property for grouped methods
        IOrderedEnumerable<IGrouping<string, HandlerRegistrationInfo>> groups = registrationsList
            .Where(r => r.Group != null)
            .GroupBy(r => r.Group!)
            .OrderBy(g => g.Key);

        foreach (IGrouping<string, HandlerRegistrationInfo>? group in groups)
        {
            sb.AppendLine();
            EmitGroupMethod(sb, group.Key, group);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void EmitGroupMethod(
        StringBuilder sb,
        string groupName,
        IEnumerable<HandlerRegistrationInfo> registrations)
    {
        var methodName = $"Add{groupName}";

        sb.AppendLine("        /// <summary>");
        sb.Append("        /// Adds handlers from group '");
        sb.Append(groupName);
        sb.AppendLine("' to the service collection.");
        sb.AppendLine("        /// </summary>");
        sb.Append("        public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection ");
        sb.Append(methodName);
        sb.AppendLine("(");
        sb.AppendLine("            this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
        sb.AppendLine("        {");

        foreach (HandlerRegistrationInfo registration in registrations)
        {
            EmitHandlerRegistration(sb, registration);
        }

        sb.AppendLine("            return services;");
        sb.AppendLine("        }");
    }

    private static void EmitHandlerRegistration(StringBuilder sb, HandlerRegistrationInfo registration)
    {
        // Register handler with appropriate lifetime
        sb.Append("            services.Add");
        sb.Append(registration.Lifetime);
        sb.Append("<");
        sb.Append(registration.FullyQualifiedClassName);
        sb.AppendLine(">();");
    }
}
